{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/FrontEndWebsite/src/components/scene/MainScene.tsx"],"sourcesContent":["'use client';\n\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { useRef, useMemo, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { EffectComposer, Bloom } from '@react-three/postprocessing';\n\ninterface ParticleSystemProps {\n  scrollProgress: number;\n}\n\nfunction ParticleSystem({ scrollProgress }: ParticleSystemProps) {\n  const meshRef = useRef<THREE.InstancedMesh>(null);\n  const particleCount = 500;\n\n  // Generate initial particle positions and velocities - using a seeded approach\n  const particleData = useMemo(() => {\n    const positions = new Float32Array(particleCount * 3);\n    const velocities = new Float32Array(particleCount * 3);\n\n    // Use a simple seeded random to avoid Math.random in render\n    let seed = 12345;\n    const seededRandom = () => {\n      seed = (seed * 9301 + 49297) % 233280;\n      return seed / 233280;\n    };\n\n    for (let i = 0; i < particleCount; i++) {\n      const i3 = i * 3;\n      // Random initial positions\n      positions[i3] = (seededRandom() - 0.5) * 20;\n      positions[i3 + 1] = (seededRandom() - 0.5) * 20;\n      positions[i3 + 2] = (seededRandom() - 0.5) * 20;\n      \n      // Random velocities for chaotic movement\n      velocities[i3] = (seededRandom() - 0.5) * 0.02;\n      velocities[i3 + 1] = (seededRandom() - 0.5) * 0.02;\n      velocities[i3 + 2] = (seededRandom() - 0.5) * 0.02;\n    }\n\n    return { positions, velocities };\n  }, []);\n\n  // Mutable refs for animation data\n  const currentPositions = useRef(new Float32Array(particleData.positions));\n  const currentVelocities = useRef(new Float32Array(particleData.velocities));\n\n  // Calculate grid positions for Act II\n  const gridPositions = useMemo(() => {\n    const positions = new Float32Array(particleCount * 3);\n    const gridSize = Math.ceil(Math.pow(particleCount, 1 / 3));\n    const spacing = 1.5;\n\n    for (let i = 0; i < particleCount; i++) {\n      const i3 = i * 3;\n      const x = (i % gridSize) - gridSize / 2;\n      const y = (Math.floor(i / gridSize) % gridSize) - gridSize / 2;\n      const z = Math.floor(i / (gridSize * gridSize)) - gridSize / 2;\n\n      positions[i3] = x * spacing;\n      positions[i3 + 1] = y * spacing;\n      positions[i3 + 2] = z * spacing;\n    }\n\n    return positions;\n  }, []);\n\n  useEffect(() => {\n    if (!meshRef.current) return;\n\n    const dummy = new THREE.Object3D();\n    \n    // Initialize instances with current positions\n    for (let i = 0; i < particleCount; i++) {\n      dummy.position.set(\n        currentPositions.current[i * 3],\n        currentPositions.current[i * 3 + 1],\n        currentPositions.current[i * 3 + 2]\n      );\n      dummy.updateMatrix();\n      meshRef.current.setMatrixAt(i, dummy.matrix);\n    }\n    meshRef.current.instanceMatrix.needsUpdate = true;\n  }, [particleCount]);\n\n  useFrame((state) => {\n    if (!meshRef.current) return;\n\n    const time = state.clock.getElapsedTime();\n    const dummy = new THREE.Object3D();\n\n    // Determine which act we're in based on scroll progress\n    const isActOne = scrollProgress < 0.25;\n    const isActTwo = scrollProgress >= 0.25 && scrollProgress < 0.5;\n\n    for (let i = 0; i < particleCount; i++) {\n      const i3 = i * 3;\n\n      if (isActOne) {\n        // ACT I: Chaotic movement with noise\n        currentPositions.current[i3] += currentVelocities.current[i3] + Math.sin(time + i) * 0.001;\n        currentPositions.current[i3 + 1] += currentVelocities.current[i3 + 1] + Math.cos(time + i) * 0.001;\n        currentPositions.current[i3 + 2] += currentVelocities.current[i3 + 2] + Math.sin(time * 0.5 + i) * 0.001;\n\n        // Boundary check - wrap around\n        for (let j = 0; j < 3; j++) {\n          if (Math.abs(currentPositions.current[i3 + j]) > 10) {\n            currentPositions.current[i3 + j] = -Math.sign(currentPositions.current[i3 + j]) * 10;\n          }\n        }\n      } else if (isActTwo) {\n        // ACT II: Transition to grid\n        const transitionProgress = (scrollProgress - 0.25) / 0.25;\n        const easedProgress = Math.min(1, transitionProgress);\n\n        for (let j = 0; j < 3; j++) {\n          const current = currentPositions.current[i3 + j];\n          const target = gridPositions[i3 + j];\n          currentPositions.current[i3 + j] = current + (target - current) * easedProgress * 0.05;\n        }\n      }\n\n      dummy.position.set(\n        currentPositions.current[i3],\n        currentPositions.current[i3 + 1],\n        currentPositions.current[i3 + 2]\n      );\n      dummy.scale.setScalar(0.05);\n      dummy.updateMatrix();\n      meshRef.current.setMatrixAt(i, dummy.matrix);\n    }\n\n    meshRef.current.instanceMatrix.needsUpdate = true;\n\n    // Color transition from red to cyan\n    const material = meshRef.current.material as THREE.MeshBasicMaterial;\n    if (isActOne) {\n      material.color.setHex(0xFF2A2A); // Red (jamming)\n    } else if (isActTwo) {\n      const colorTransition = (scrollProgress - 0.25) / 0.25;\n      const r = 1 - colorTransition;\n      const g = 0.83 * colorTransition;\n      const b = 0.17 + 0.83 * colorTransition;\n      material.color.setRGB(r, g, b);\n    }\n  });\n\n  return (\n    <instancedMesh ref={meshRef} args={[undefined, undefined, particleCount]}>\n      <sphereGeometry args={[1, 8, 8]} />\n      <meshBasicMaterial />\n    </instancedMesh>\n  );\n}\n\nfunction VineLines({ scrollProgress }: { scrollProgress: number }) {\n  const linesRef = useRef<THREE.Group>(null);\n\n  // Use memoized random positions to avoid re-rendering with different positions\n  const linePositions = useMemo(() => {\n    const lineCount = 20;\n    const gridSize = 8;\n    const spacing = 1.5;\n    const positions = [];\n\n    // Use seeded random for consistent positions\n    let seed = 54321;\n    const seededRandom = () => {\n      seed = (seed * 9301 + 49297) % 233280;\n      return seed / 233280;\n    };\n\n    for (let i = 0; i < lineCount; i++) {\n      const startX = (seededRandom() * gridSize - gridSize / 2) * spacing;\n      const startY = (seededRandom() * gridSize - gridSize / 2) * spacing;\n      const startZ = (seededRandom() * gridSize - gridSize / 2) * spacing;\n\n      const endX = (seededRandom() * gridSize - gridSize / 2) * spacing;\n      const endY = (seededRandom() * gridSize - gridSize / 2) * spacing;\n      const endZ = (seededRandom() * gridSize - gridSize / 2) * spacing;\n\n      positions.push({ start: [startX, startY, startZ], end: [endX, endY, endZ] });\n    }\n\n    return positions;\n  }, []);\n\n  useEffect(() => {\n    if (!linesRef.current) return;\n\n    // Clear existing lines\n    while (linesRef.current.children.length > 0) {\n      linesRef.current.remove(linesRef.current.children[0]);\n    }\n\n    // Only show lines in Act II when grid is forming\n    if (scrollProgress >= 0.25 && scrollProgress < 0.5) {\n      linePositions.forEach(({ start, end }) => {\n        const points = [\n          new THREE.Vector3(start[0], start[1], start[2]),\n          new THREE.Vector3(end[0], end[1], end[2])\n        ];\n\n        const geometry = new THREE.BufferGeometry().setFromPoints(points);\n        const material = new THREE.LineBasicMaterial({\n          color: 0x00D4FF,\n          opacity: 0.3,\n          transparent: true,\n        });\n        const line = new THREE.Line(geometry, material);\n        linesRef.current?.add(line);\n      });\n    }\n  }, [scrollProgress, linePositions]);\n\n  return <group ref={linesRef} />;\n}\n\ninterface MainSceneProps {\n  scrollProgress: number;\n  lowPowerMode?: boolean;\n}\n\nexport default function MainScene({ scrollProgress, lowPowerMode = false }: MainSceneProps) {\n  return (\n    <div className=\"fixed inset-0 z-0\">\n      <Canvas\n        camera={{ position: [0, 0, 15], fov: 75 }}\n        gl={{ \n          antialias: !lowPowerMode,\n          powerPreference: lowPowerMode ? 'low-power' : 'high-performance',\n        }}\n      >\n        <ambientLight intensity={0.5} />\n        <ParticleSystem scrollProgress={scrollProgress} />\n        <VineLines scrollProgress={scrollProgress} />\n        \n        {!lowPowerMode && (\n          <EffectComposer>\n            <Bloom\n              intensity={0.5}\n              luminanceThreshold={0.2}\n              luminanceSmoothing={0.9}\n            />\n          </EffectComposer>\n        )}\n      </Canvas>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}}]
}